<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>rise-video test</title>

    <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../node_modules/mocha/mocha.js"></script>
    <script src="../../node_modules/chai/chai.js"></script>
    <script src="../../node_modules/sinon/pkg/sinon.js"></script>
    <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>

    <script type="text/javascript">
      const FILES = "test1.mp4|test2.png|test3.webm";
      const sampleUrl = path => `https://storage.googleapis.com/${ path }`;

      RisePlayerConfiguration = {
        isConfigured: () => true,
        isPreview: () => false,
        Logger: {
          info: sinon.spy(),
          error: sinon.spy(),
          warning: sinon.spy()
        },
        LocalStorage: {
          watchSingleFile: (file, handler) => {
            handler( { status: "CURRENT", filePath: file, fileUrl: sampleUrl( file ) } );
          }
        },
        Helpers: {
          isEditorPreview: () => false
        }
      };

      const videojs = () => {
        const videojs = {
          currentSrc: sinon.spy(),
          exitFullscreen: sinon.spy(),
          getChild: sinon.spy(),
          error: sinon.spy(),
          muted: sinon.spy(),
          on: sinon.spy(),
          play: sinon.spy( sinon.stub().resolves() ),
          playlist: sinon.spy(),
          removeChild: sinon.spy(),
          reset: sinon.spy(),
          videoHeight: sinon.spy(),
          videoWidth: sinon.spy(),
          volume: sinon.spy()
        };

        videojs.playlist.currentItem = sinon.spy();
        videojs.playlist.first = sinon.spy();
        videojs.playlist.next = sinon.spy();

        return videojs;
      };
    </script>

    <script type="module" src="../../src/rise-video.js"></script>
  </head>
  <body>

    <test-fixture id="test-block">
      <template>
        <rise-video
          id="rise-video-01"
          files="test1.mp4|test2.png|test3.webm"
          play-until-done>
        </rise-video>
      </template>
    </test-fixture>

    <test-fixture id="test-block-without-pud">
      <template>
        <rise-video
          id="rise-video-01"
          files="test1.mp4|test2.png|test3.webm">
        </rise-video>
      </template>
    </test-fixture>

    <script type="module">
      let element;

      suite( "logging", () => {
        setup (() => {
          element = fixture( "test-block" );
          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        const componentData = {
          name: "rise-video",
          id: "rise-video-01",
          version: "__VERSION__"
        };

        test( "should log 'video-start' event with correct params", () => {
          assert.deepEqual( RisePlayerConfiguration.Logger.info.lastCall.args[ 0 ], componentData );
          assert.equal( RisePlayerConfiguration.Logger.info.lastCall.args[ 1 ], "video-start" );
          assert.deepEqual( RisePlayerConfiguration.Logger.info.lastCall.args[ 2 ], { files: FILES } );
        } );

        test( "should log 'video-reset' event with correct params when files change", () => {
          element.files = "foo.mp4|bar.webm";

          assert.equal( RisePlayerConfiguration.Logger.info.lastCall.args[ 1 ], "video-reset" );
          assert.deepEqual( RisePlayerConfiguration.Logger.info.lastCall.args[ 2 ], { files: "foo.mp4|bar.webm" } );
        } );

        test( "should log 'video-reset' event with correct params when metadata changes", () => {
          element.metadata = [ { file: "foo.mp4" }, { file: "bar.webm" } ];

          assert.equal( RisePlayerConfiguration.Logger.info.lastCall.args[ 1 ], "video-reset" );
          assert.deepEqual( RisePlayerConfiguration.Logger.info.lastCall.args[ 2 ], { files: [ "foo.mp4", "bar.webm" ] } );
        } );
      } );

      suite( "rise-video", () => {
        setup (() => {
          element = fixture( "test-block" );
        } );

        test( "component exists", () => {
          assert.isOk( element );
        } );

        test( "_initialStart is updated correctly", () => {
          assert.isTrue( element._initialStart );

          element.dispatchEvent( new CustomEvent( "start" ) );

          assert.isFalse( element._initialStart );
        });

        test( "attributes should be set correctly", () => {
          assert.equal( element.files, "test1.mp4|test2.png|test3.webm" );
          assert.strictEqual( element.volume, 0 );
          assert.strictEqual( element.playUntilDone, true );
        } );
      });

      suite( "valid filenames", () => {
        setup (() => {
          element = fixture( "test-block" );
          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        test( "invalid files are filtered out", () => {
          assert.deepEqual( element._validFiles, [ "test1.mp4", "test3.webm" ] );
        } );

        test( "valid filenames are updated when files property changes", () => {
          element.files = "foo.mp4|bar.webm|baz.jpg";

          assert.deepEqual( element._validFiles, [ "foo.mp4", "bar.webm" ] );
        });

        test( "valid filenames are updated when metadata property changes", () => {
          element.metadata = [ { file: "foo.mp4" }, { file: "bar.webm" }, { file: "baz.jpg" } ];

          assert.deepEqual( element._validFiles, [ "foo.mp4", "bar.webm" ] );
        });
      } );

      suite( "watched files", () => {
        setup (() => {
          element = fixture( "test-block" );
        } );

        test( "files to render should be populated", () => {
          element.dispatchEvent( new CustomEvent( "start" ) );

          assert.equal( element._filesToRenderList.length, 2 );
        } );

        test( "deleted files should be removed from list of files to render", () => {
          element.dispatchEvent( new CustomEvent( "start" ) );

          element._handleSingleFileUpdate( {
            filePath: "test3.webm",
            fileUrl: sampleUrl( "test3.webm" ),
            status: "deleted",
          } );

          assert.equal( element._filesToRenderList.length, 1 );
        } );

        test( "errors should be handled", () => {
          sinon.stub( RisePlayerConfiguration.LocalStorage, 'watchSingleFile').callsFake( (file, handler) => {
            handler({
              filePath: file,
              fileUrl: null,
              status: "FILE-ERROR",
              errorMessage: "download error",
              errorDetail: "network failure"
            } );
          } );
          sinon.spy( element, "watchedFileErrorCallback" );

          element.dispatchEvent( new CustomEvent( "start" ) );

          assert.equal( element.watchedFileErrorCallback.callCount, 2 );
          assert.equal( element._filesToRenderList.length, 0 );

          RisePlayerConfiguration.LocalStorage.watchSingleFile.restore();
          element.watchedFileErrorCallback.restore();
        } );

        test( "watched files are updated when files property changes", () => {
          element.dispatchEvent( new CustomEvent( "start" ) );

          element.files = "foo.mp4|bar.webm|baz.jpg";

          assert.deepEqual( element.managedFiles, [ { filePath: "foo.mp4", fileUrl: sampleUrl("foo.mp4"), order: 0 }, { filePath: "bar.webm", fileUrl: sampleUrl("bar.webm"), order: 1 } ] );
        });

        test( "watched files are updated when metadata property changes", () => {
          element.dispatchEvent( new CustomEvent( "start" ) );

          element.metadata = [ { file: "foo.mp4" }, { file: "bar.webm" }, { file: "baz.jpg" } ];

          assert.deepEqual( element.managedFiles, [ { filePath: "foo.mp4", fileUrl: sampleUrl("foo.mp4"), order: 0 }, { filePath: "bar.webm", fileUrl: sampleUrl("bar.webm"), order: 1 } ] );
        });

        test( "_filesToRenderList is updated correctly when metadata has no files", () => {
          element.dispatchEvent( new CustomEvent( "start" ) );

          assert.strictEqual( element._filesToRenderList.length, 2);

          element.metadata = [];

          assert.strictEqual( element._filesToRenderList.length, 0);
        } );
      } );

      suite( "watched file updates", () => {
        setup( () => {
          sinon.stub( RisePlayerConfiguration.LocalStorage, 'watchSingleFile').callsFake( (file, handler) => {
            setTimeout( () => {
              handler( { status: "CURRENT", filePath: file, fileUrl: sampleUrl( file ) } );
            }, 100);
          } );

          element = fixture( "test-block" );
        } );

        teardown( () => {
          RisePlayerConfiguration.LocalStorage.watchSingleFile.restore();
        } );

        test( "_filesToRenderList should not contain watched files which are returned after they're no longer needed", done => {
          element.dispatchEvent( new CustomEvent( "start" ) );

          element.metadata = [ {file: "newFile1.mp4"}, {file: "newFile2.mp4"} ];

          setTimeout( () => {
            assert.equal( element.managedFiles.length, 4 );
            assert.deepEqual( element._filesToRenderList, [
              { filePath: "newFile1.mp4", fileUrl: sampleUrl( "newFile1.mp4" ), order: 0 },
              { filePath: "newFile2.mp4", fileUrl: sampleUrl( "newFile2.mp4" ), order: 1 }
            ]);
            done();
          }, 200 );
        } );
      } );

      suite( "volume", () => {
        setup (() => {
          element = fixture( "test-block" );
        } );

        test( "volume defaults to 0", () => {
          assert.strictEqual( element.volume, 0 );
        } );

        test( "volume updates in video player when changed", () => {
          element.volume = 75;

          assert.strictEqual( element.$.videoPlayer.volume, 75 );
        } );
      } );

      suite( "editor preview mode", () => {
        setup( () => {
          sinon.stub(RisePlayerConfiguration.Helpers, "isEditorPreview").returns(true);
          element = fixture( "test-block" );

          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        teardown( () => {
          RisePlayerConfiguration.Helpers.isEditorPreview.restore();
        } );

        test( "should not initialize if in editor preview mode", () => {
          assert.deepEqual( element._validFiles, [] );
        } );

        test( "should show the preview placeholder if in editor preview mode", () => {
          const style = window.getComputedStyle( element.$.previewPlaceholder );

          assert.equal( style.display, "block" );
        } );

      } );

      suite( "preview mode", () => {
        let oldIsPreview;

        setup( () => {
          oldIsPreview = RisePlayerConfiguration.isPreview;
          RisePlayerConfiguration.isPreview = sinon.spy( sinon.stub().returns( true ) );
          element = fixture( "test-block" );
        } );

        teardown( () => {
          RisePlayerConfiguration.isPreview = oldIsPreview;
        } );

        test( "_isPreview should call RisePlayerConfiguration.isPreview", () => {
          RisePlayerConfiguration.isPreview.resetHistory();

          const isPreview = element._isPreview;

          assert.strictEqual( isPreview, true );
          assert.equal( RisePlayerConfiguration.isPreview.callCount, 1 );
        } );

        test( "should hide the preview placeholder if not in editor preview mode", () => {
          const style = window.getComputedStyle( element.$.previewPlaceholder );

          assert.equal( style.display, "none" );
        } );

        test( "should initialize valid files and call _handleStartForPreview()", () => {
          sinon.stub(element, "_handleStartForPreview")
          element._start();

          assert.deepEqual( element._validFiles, ["test1.mp4", "test3.webm"] );
          assert.isTrue(element._handleStartForPreview.called);

          element._handleStartForPreview.restore();
        } );

      } );

      suite( "get default files", () => {
        setup (() => {
          element = fixture( "test-block" );
        } );

        test( "_getDefaultFiles should return the correct files", () => {
          element.files = "foo.mp4";

          assert.deepEqual( element._getDefaultFiles(), ["foo.mp4"] );

          element.files = "foo.mp4|bar.mp4";

          assert.deepEqual( element._getDefaultFiles(), ["foo.mp4", "bar.mp4"] );
        } );

        test( "_getDefaultFiles should handle empty strings correctly", () => {
          element.files = "";

          assert.strictEqual( element._getDefaultFiles().length, 0 );
        } );

        test( "_getDefaultFiles should handle extra whitespace correctly", () => {
          element.files = "   foo.mp4 |  bar.mp4       ";

          assert.deepEqual( element._getDefaultFiles(), ["foo.mp4", "bar.mp4"] );
        } );
      })

      suite( "get metadata", () => {
        setup (() => {
          element = fixture( "test-block" );
        } );

        test( "should handle no metadata", () => {
          element.metadata = null;

          assert.strictEqual( element._getFilesFromMetadata().length, 0 );
        } );

        test( "should return files correctly", () => {
          element.metadata = [{ file: "foo.mp4" }, { file: "bar.webm" }];

          assert.deepEqual( element._getFilesFromMetadata(), [ "foo.mp4", "bar.webm" ] );
        } );
      } );

      suite( "play until done", () => {
        setup( () => {
          element = fixture( "test-block" );
          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        test( "should not set up files done timer if no files are provided", () => {
          assert.isNotOk( element._noFilesDoneTimer);
        } );

        test( "should set up no files done timer if no files are provided", () => {
          element.metadata = [];

          assert.isOk( element._noFilesDoneTimer);
        } );

        test( "should emit report-done event if play until done is enabled", () => {
          sinon.spy( element, "_sendDoneEvent");

          element._done();

          assert.strictEqual( element._sendDoneEvent.callCount, 1);

          element._sendDoneEvent.restore();
        } );

        test( "should call _done() when first download timer fires, if no files have been downloaded", () => {
          sinon.spy( element, '_done' );

          element.managedFiles = [];
          element._handleFirstDownloadTimer();

          assert.equal( element._done.callCount, 1 );

          element._done.restore();
        } );

        test( "should not call _done() when first download timer fires, if some files have been downloaded", () => {
          sinon.spy( element, '_done' );

          element.managedFiles = ["a", "b", "c"];
          element._handleFirstDownloadTimer();

          assert.equal( element._done.callCount, 0 );

          element._done.restore();
        } );


        test( "should call _done() when no files timer fires", () => {
          sinon.spy( element, '_done' );

          element._handleNoFilesTimer();

          assert.equal( element._done.callCount, 1 );

          element._done.restore();
        } );
      } );

      suite( "play until done disabled", () => {
        test( "attribute should be set correctly", () => {
          assert.strictEqual( element.playUntilDone, false );
        } );

        setup( () => {
          element = fixture( "test-block-without-pud" );
        } );

        test( "should not emit report-done event if play until done is disabled", () => {
          sinon.spy( element, "_sendDoneEvent");

          element._done();

          assert.strictEqual( element._sendDoneEvent.callCount, 0);

          element._sendDoneEvent.restore();
        } );
      } );

      suite( "play until done with no files downloaded", () => {
        setup( () => {
          sinon.stub( RisePlayerConfiguration.LocalStorage, 'watchSingleFile').callsFake( () => {} );
          element = fixture( "test-block" );
          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        teardown( () => {
          RisePlayerConfiguration.LocalStorage.watchSingleFile.restore();
        } );

        test( "should set up first download timer when files aren't already in storage", () => {
          assert.isOk( element._firstDownloadTimer );
        } );

        test( "should clear first download timer if a file is received", () => {
          assert.isOk( element._firstDownloadTimer );

          element.managedFiles = []
        } );
      } );

      suite( "play until done with files downloaded", () => {
        setup( () => {
          element = fixture( "test-block" );
        } );

        test( "should set up first download timer when files aren't already in storage", () => {
          assert.isNotOk( element._firstDownloadTimer );
        } );
      });

      suite( "presentation-events", () => {
        setup( () => {
          element = fixture( "test-block" );
          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        test( "calling _stop should clear timeouts and stop playing videos", () => {
          assert.isOk( element._validFiles.length );
          assert.isOk( element._filesToRenderList.length );

          element._waitForFirstDownload();
          element._handleNoFiles();
          element._stop();

          assert.deepEqual( element._validFiles, [] );
          assert.deepEqual( element._filesToRenderList, [] );
          assert.strictEqual( element._firstDownloadTimer, null );
          assert.strictEqual( element._noFilesDoneTimer, null );
        } );

        test( "should call _stop when rise-presentation-stop is received", () => {
          sinon.spy( element, "_stop");

          element.dispatchEvent( new CustomEvent( "rise-presentation-stop" ) );

          assert.equal( element._stop.callCount, 1 );

          element._stop.restore();
        } );

        test( "should call _reset when rise-presentation-play is received", () => {
          sinon.spy( element, "_reset");

          element.dispatchEvent( new CustomEvent( "rise-presentation-play" ) );

          assert.equal( element._reset.callCount, 1 );

          element._reset.restore();
        } );
      } );

      suite( "uptime", () => {
        setup( () => {
          element = fixture( "test-block" );
          sinon.spy( element, "_setUptimeError" );

          element.dispatchEvent( new CustomEvent( "start" ) );
        } );

        teardown( () => {
          element._setUptimeError.restore();
        } );

        test( "should end uptime when no valid files are provided", () => {
          element.metadata = [ { file: "foo.jpg" }, { file: "bar.csv" } ];

          assert.deepEqual( element._setUptimeError.lastCall.args, [ true ] );
        } );

        test( "should not end uptime when no files are provided", () => {
          element.metadata = [];

          assert.deepEqual( element._setUptimeError.lastCall.args, [ false ] );
        } );

        test( "shoud reset uptime when _reset is called", () => {
          element._reset();
          assert.isOk( element._setUptimeError.calledOnceWithExactly( false ) );
        } );
      } );

      suite( "_filePathIsRendered", () => {
        setup( () => {
          element = fixture( "test-block" );
        } );

        test( "should find by filepath", () => {
          element._filesToRenderList = [
            { filePath: "a.txt" },
            { filePath: "b.txt" },
            { filePath: "c.txt" }
          ];

          assert.isOk( element._filePathIsRendered( "b.txt" ) );
        } );

        test( "should not find if not in list", () => {
          element._filesToRenderList = [
            { filePath: "a.txt" },
            { filePath: "b.txt" },
            { filePath: "c.txt" }
          ];

          assert.isNotOk( element._filePathIsRendered( "d.txt" ) );
        } );
      });

      suite( "_configureShowingVideos", () => {
        setup( () => {
          element = fixture( "test-block" );
        } );

        test( "should find by filepath", () => {
          element._presentationStarted = true;
          element.managedFiles = [
            { filePath: "a.txt" },
            { filePath: "b.txt" },
            { filePath: "c.txt" }
          ];
          element._validFiles = [ "a.txt", "c.txt" ];

          const expectedFiles = [
            { filePath: "a.txt" },
            { filePath: "c.txt" }
          ];

          element._configureShowingVideos();

          assert.deepEqual( element._filesToRenderList, expectedFiles );
        } );

        test( "should not configure showing videos if presentation has not started", () => {
          element._presentationStarted = false;
          const currentList = element._filesToRenderList;

          element._configureShowingVideos();

          assert.equal( element._filesToRenderList, currentList );
        } );
      } );

      suite( "watchedFileDeletedCallback", () => {
        setup( () => {
          element = fixture( "test-block" );
        } );

        test( "should not configure showing videos if presentation has not started", () => {
          element._filesToRenderList = [
            { filePath: "a.txt" }
          ];
          element._filePathIsRendered = () => true;

          element.watchedFileDeletedCallback({ filePath: "a.txt" });

          assert.deepEqual( element._filesToRenderList, [] );
        } );
      } );

      suite( "_previewStatusFor", () => {
        setup( () => {
          element = fixture( "test-block" );
        } );

        test( "should get current status if there is no metadata", () => {

          const status = element._previewStatusFor( "risemedialibrary-abc123/test1.webm" );

          assert.equal( status, "current" );
        });

        test( "should get current status if metadata says that file exists", () => {
          element.metadata = [{
            "file": "risemedialibrary-abc123/test1.webm",
            "exists": true
          }, {
            "file": "risemedialibrary-abc123/test2.webm",
            "exists": true
          }];

          const status = element._previewStatusFor( "risemedialibrary-abc123/test2.webm" );

          assert.equal( status, "current" );
        });

        test( "should get deleted status if metadata says that file doesn't exist", () => {
          element.metadata = [{
            "file": "risemedialibrary-abc123/test1.webm",
            "exists": true
          }, {
            "file": "risemedialibrary-abc123/test2.webm",
            "exists": false
          }];

          const status = element._previewStatusFor( "risemedialibrary-abc123/test2.webm" );

          assert.equal( status, "deleted" );
        });

        test( "should get deleted status if metadata is not empty but does not contain the file", () => {
          element.metadata = [{
            "file": "risemedialibrary-abc123/test1.webm",
            "exists": true
          }];

          const status = element._previewStatusFor( "risemedialibrary-abc123/test2.webm" );

          assert.equal( status, "deleted" );
        } );

        test( "should get deleted status if metadata is empty", () => {
          element.metadata = [];

          const status = element._previewStatusFor( "risemedialibrary-abc123/test1.webm" );

          assert.equal( status, "deleted" );
        });

      });

      suite( "_getFileUrl", () => {
        setup( () => {
          element = fixture( "test-block" );
        } );

        test( "should encode file path", () => {
          let filePath = "risemedialibrary-abc123/testing/UÌˆ-+ test%20encoding ([!@?,#$])=1+2-A&%.webm";
          let fileUrl = element._getFileUrl( filePath );

          assert.isTrue(fileUrl.indexOf("/risemedialibrary-abc123/") > 0, "forward slash in file path is not encoded" );
        } );

      } );

      suite( "_handleStartForPreview", () => {
        setup( () => {
          element = fixture( "test-block" );
          sinon.stub(element.__proto__.__proto__, "handleFileStatusUpdated");
        });

        teardown( () => {
          element.metadata = null;

          element.handleFileStatusUpdated.restore();
        } );

        test( "should call handleFileStatusUpdated with correct data", () => {
          element._validFiles = [ "risemedialibrary-abc123/test.webm" ];
          element._handleStartForPreview();

          assert.isTrue( element.handleFileStatusUpdated.calledWith({
            filePath: "risemedialibrary-abc123/test.webm",
            fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test.webm",
            status: "current"
          } ));
        } );

        test( "should call handleFileStatusUpdated for each file", () => {
          element._validFiles = [ "risemedialibrary-abc123/test1.webm", "risemedialibrary-abc123/test2.webm", "risemedialibrary-abc123/test3.webm" ];
          element._handleStartForPreview();

          assert.deepEqual( element.__proto__.__proto__.handleFileStatusUpdated.args[0][0], {
            filePath: "risemedialibrary-abc123/test1.webm",
            fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test1.webm",
            status: "current"
          } );

          assert.deepEqual( element.__proto__.__proto__.handleFileStatusUpdated.args[1][0], {
            filePath: "risemedialibrary-abc123/test2.webm",
            fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test2.webm",
            status: "current"
          } );

          assert.deepEqual( element.__proto__.__proto__.handleFileStatusUpdated.args[2][0], {
            filePath: "risemedialibrary-abc123/test3.webm",
            fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test3.webm",
            status: "current"
          } );
        } );

      } );

      suite( "_fetchVideosForPreview", () => {
        setup( () => {
          element = fixture( "test-block" );

          sinon.stub(element, "_fetchFileForPreview").callsFake((file) => {
            return Promise.resolve(`blob:${file.fileUrl}`);
          });
          sinon.spy(element, "_clearFirstDownloadTimer");
        });

        teardown( () => {
          element._fetchFileForPreview.restore();
          element._clearFirstDownloadTimer.restore();
        } );

        test( "should sequentially add files to _filesToRenderList array and complete with the array fully populated", (done) => {
          const files = [
            { filePath: "a.webm", fileUrl: "https://test.com/a.webm" },
            { filePath: "b.webm", fileUrl: "https://test.com/b.webm" },
            { filePath: "c.webm", fileUrl: "https://test.com/c.webm" }
          ];

          element._fetchVideosForPreview( files )
            .then( () => {
              assert.isTrue(element._fetchingVideosForPreview);
              assert.equal(element._fetchFileForPreview.callCount, 3);
              assert.isTrue(element._clearFirstDownloadTimer.called);
              assert.deepEqual(element._filesToRenderList, [
                { filePath: "a.webm", fileUrl: "blob:https://test.com/a.webm" },
                { filePath: "b.webm", fileUrl: "blob:https://test.com/b.webm" },
                { filePath: "c.webm", fileUrl: "blob:https://test.com/c.webm" }
              ]);
              done();
            })
            .catch(err => {
              console.log("shouldn't be here", err);
              assert.fail();
              done();
            });
        } );

        test( "should not add files to _filesToRenderList array if abort flag is on", (done) => {
          const files = [
            { filePath: "a.webm", fileUrl: "https://test.com/a.webm" },
            { filePath: "b.webm", fileUrl: "https://test.com/b.webm" },
            { filePath: "c.webm", fileUrl: "https://test.com/c.webm" }
          ];

          element._abortFetchingVideosForPreview = true;
          element._fetchVideosForPreview( files )
          .then( () => {
            assert.isFalse(element._fetchFileForPreview.called);
            assert.deepEqual(element._filesToRenderList, []);

            done();
          } )
            .catch(err => {
              console.log("shouldn't be here", err);
              assert.fail();
              done();
            });
        } );

        test( "should not add file to _filesToRenderList array if abort flag turned on while processing a fetch", (done) => {
          const files = [
            { filePath: "a.webm", fileUrl: "https://test.com/a.webm" },
            { filePath: "b.webm", fileUrl: "https://test.com/b.webm" },
            { filePath: "c.webm", fileUrl: "https://test.com/c.webm" }
          ];

          element._fetchFileForPreview.restore();
          sinon.stub(element, "_fetchFileForPreview").callsFake((file) => {
            if ( element._fetchFileForPreview.callCount > 1 ) {
              element._abortFetchingVideosForPreview = true;
            }

            return Promise.resolve(`blob:${file.fileUrl}`);
          });

          element._fetchVideosForPreview( files )
            .then( () => {
              assert.equal(element._fetchFileForPreview.callCount, 2);
              assert.deepEqual(element._filesToRenderList, [
                { filePath: "a.webm", fileUrl: "blob:https://test.com/a.webm" }
              ]);

              done();
            } )
            .catch(err => {
              console.log("shouldn't be here", err);
              assert.fail();
              done();
            });
        } );
      } );

      suite( "_configureShowingVideosForPreview", () => {
        setup( () => {

          element = fixture( "test-block" );

          sinon.stub(element, "_fetchVideosForPreview").callsFake(() => {
            element._fetchingVideosForPreview = true;

            return Promise.resolve();
          });
          sinon.spy(element, "_waitForFirstDownload");
        });

        teardown( () => {
          element._fetchVideosForPreview.restore();
          element._waitForFirstDownload.restore();
        } );

        test( "should not execute if presentation has not started", () => {
          element._presentationStarted = false;
          element._configureShowingVideosForPreview();

          assert.isFalse(element._fetchVideosForPreview.called);
        } );

        test( "should recursively wait to execute until previous sequential fetch is complete based on flag", () => {
          let clock = sinon.useFakeTimers();

          sinon.spy(element, "_configureShowingVideosForPreview");

          element._presentationStarted = true;
          element._fetchingVideosForPreview = true;
          element._configureShowingVideosForPreview();

          clock.tick(500);
          assert.equal(element._configureShowingVideosForPreview.callCount, 2);
          assert.isFalse(element._fetchVideosForPreview.called);

          clock.tick(500);
          assert.equal(element._configureShowingVideosForPreview.callCount, 3);
          assert.isFalse(element._fetchVideosForPreview.called);

          // mock previous sequential fetching completed
          element._fetchingVideosForPreview = false;

          clock.tick(500);
          assert.equal(element._configureShowingVideosForPreview.callCount, 4);
          assert.isTrue(element._fetchVideosForPreview.called);

          clock.restore();
        } );

        test( "should call _fetchVideosForPreview with managed files and set flags when complete", (done) => {
          const files = [
            { filePath: "a.webm", fileUrl: "https://test.com/a.webm" },
            { filePath: "b.webm", fileUrl: "https://test.com/b.webm" },
            { filePath: "c.webm", fileUrl: "https://test.com/c.webm" }
          ];

          element._presentationStarted = true;
          element.managedFiles = files;
          element._configureShowingVideosForPreview();

          setTimeout(() => {
            assert.isTrue(element._waitForFirstDownload.called);
            assert.isTrue(element._fetchVideosForPreview.calledWith(files));
            assert.isFalse(element._fetchingVideosForPreview);
            assert.isFalse(element._abortFetchingVideosForPreview);

            done();
          }, 200);

        } );
      } );

      suite( "_handleFirstDownloadTimer", () => {
        setup( () => {
          element = fixture( "test-block" );
          sinon.stub(element, "_done");
        });

        teardown( () => {
          element._done.restore();
        } );

        test( "should call done if preview and _filesToRenderList is empty", () => {
          sinon.stub(RisePlayerConfiguration, "isPreview").returns(true);

          element._handleFirstDownloadTimer();
          assert.isTrue(element._done.called);

          RisePlayerConfiguration.isPreview.restore();
        } );

        test( "should not call done if preview and _filesToRenderList is not empty", () => {
          sinon.stub(RisePlayerConfiguration, "isPreview").returns(true);

          element._filesToRenderList = [{ filePath: "newFile1.mp4", fileUrl: sampleUrl( "newFile1.mp4" ), order: 0 }];
          element._handleFirstDownloadTimer();
          assert.isFalse(element._done.called);

          RisePlayerConfiguration.isPreview.restore();
        } );

        test( "should call done if not preview and managedFiles is empty", () => {
          element._handleFirstDownloadTimer();
          assert.isTrue(element._done.called);

        } );

        test( "should not call done if not preview and managedFiles is not empty", () => {
          element.managedFiles = [{ filePath: "newFile1.mp4", fileUrl: sampleUrl( "newFile1.mp4" ), order: 0 }];
          element._handleFirstDownloadTimer();
          assert.isFalse(element._done.called);
        } );

      } );

    </script>
  </body>
</html>
